# generated by datamodel-codegen:
#   filename:  dbt_yml_files-latest.json
#   timestamp: 2024-07-25T00:00:09+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Column(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    data_type: str = ""


class Type(Enum):
    dashboard = "dashboard"
    notebook = "notebook"
    analysis = "analysis"
    ml = "ml"
    application = "application"


class Maturity(Enum):
    high = "high"
    medium = "medium"
    low = "low"


class Argument(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    type: str = ""


class Access(Enum):
    private = "private"
    protected = "protected"
    public = "public"


class Defaults(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    agg_time_dimension: str = ""


class Format(Enum):
    csv = "csv"
    dict = "dict"
    sql = "sql"


class ExpectDict(BaseModel):
    format: Literal["dict"] = Field("dict")
    rows: List[Dict[str, Any]] = Field(
        ...,
        description="When `format` is `dict`, each item should be a dictionary containing a key-value pair for each column and its value, e.g. `{id: 1, code: 'ABC'}`",
    )


class ExpectCSV(BaseModel):
    format: Literal["csv"] = Field("csv")
    rows: str = Field(
        "",
        description="When `format` is csv or sql, a string containing comma-separated headers and values. Alternatively provide a fixture. Use the pipe character | to create a multi-line string in YAML.",
    )
    fixture: str = Field(
        "",
        description="Specify the name of a fixture instead of providing `rows`.",
    )


class ExpectSQL(BaseModel):
    format: Literal["sql"] = Field("sql")
    rows: str = Field(
        "",
        description="When `format` is csv or sql, a string containing comma-separated headers and values. Alternatively provide a fixture. Use the pipe character | to create a multi-line string in YAML.",
    )
    fixture: str = Field(
        "",
        description="Specify the name of a fixture instead of providing `rows`.",
    )


Expect = Union[ExpectDict, ExpectCSV, ExpectSQL]


class GivenItem(BaseModel):
    fixture: str = Field(
        "",
        description="Only relevant when format is csv. Specify the name of a fixture instead of providing `rows`.",
    )
    format: Optional[Format] = Field(
        None, description="Defaults to `dict` when not specified"
    )
    input: str = Field(
        "",
        description="The relation whose inputs you need to mock. Enclose in ref or source without curly braces",
        examples=[
            "ref('model_b')",
            "ref('upstream_project', 'model_b')",
            "source('schema', 'table')",
        ],
    )


class Overrides(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    env_vars: Optional[Dict[str, Any]] = None
    macros: Optional[Dict[str, Any]] = Field(
        None, examples=[{"is_incremental": "true"}]
    )
    vars: Optional[Dict[str, Any]] = None


class AggregationTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    percentile: Optional[float] = None
    use_approximate_percentile: Optional[bool] = None
    use_discrete_percentile: Optional[bool] = None


class ArrayOfStrings(RootModel[List[str]]):
    root: List[str]


class Calculation(Enum):
    conversions = "conversions"
    conversion_rate = "conversion_rate"
    CONVERSIONS = "CONVERSIONS"
    CONVERSION_RATE = "CONVERSION_RATE"


class ConstantProperty(BaseModel):
    base_property: str = Field(..., description="DIMENSION or ENTITY")
    conversion_property: str = Field(..., description="DIMENSION or ENTITY")


class GrainToDate(Enum):
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class TimeGranularity(Enum):
    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"
    QUARTER = "QUARTER"
    YEAR = "YEAR"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DocsConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    node_color: str = Field(
        "",
        description="The color of the node on the DAG in the documentation. It must be an Hex code or a valid CSS color name.",
        pattern="^(#[a-fA-F0-9]{3}|#[a-fA-F0-9]{6}|[^#][a-zA-Z]*)$",
    )
    show: Optional[bool] = True


class EntityType(Enum):
    PRIMARY = "PRIMARY"
    UNIQUE = "UNIQUE"
    FOREIGN = "FOREIGN"
    NATURAL = "NATURAL"
    primary = "primary"
    unique = "unique"
    foreign = "foreign"
    natural = "natural"


class Entity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        regex_engine="python-re",
    )
    name: str = Field(..., pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$")
    type: EntityType = Field(..., title="Entity Type")
    entity: str = ""
    expr: Optional[Union[str, bool]] = None


class ExportAs(Enum):
    table = "table"
    view = "view"
    cache = "cache"


class ExportConfig(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    alias: str = ""
    export_as: Optional[ExportAs] = None
    schema_: str = Field(None, alias="schema")


class Export(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    config: Optional[ExportConfig] = Field(None, title="Export Config")


class Period(Enum):
    minute = "minute"
    hour = "hour"
    day = "day"


class JinjaString(RootModel[str]):
    root: str = Field(..., pattern="\\{\\{.*\\}\\}")


class Agg(Enum):
    SUM = "SUM"
    MIN = "MIN"
    MAX = "MAX"
    AVG = "AVG"
    COUNT_DISTINCT = "COUNT_DISTINCT"
    SUM_BOOLEAN = "SUM_BOOLEAN"
    COUNT = "COUNT"
    PERCENTILE = "PERCENTILE"
    MEDIAN = "MEDIAN"
    sum = "sum"
    min = "min"
    max = "max"
    avg = "avg"
    count_distinct = "count_distinct"
    sum_boolean = "sum_boolean"
    count = "count"
    percentile = "percentile"
    median = "median"


class MetricInputMeasure(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = ""
    fill_nulls_with: Optional[Union[str, int]] = None
    filter: str = ""
    join_to_timespine: Optional[bool] = None


class MetricInputSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = ""
    alias: str = ""
    filter: str = ""
    offset_window: str = ""


class AuthorizedView(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    database: str
    project: str


class OnConfigurationChange(Enum):
    apply = "apply"
    continue_ = "continue"
    fail = "fail"


class OnSchemaChange(Enum):
    append_new_columns = "append_new_columns"
    fail = "fail"
    ignore = "ignore"
    sync_all_columns = "sync_all_columns"


class OwnerWithEmail(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    email: str


class OwnerWithName(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str


Owner = Union[OwnerWithEmail, OwnerWithName]


class WindowChoice(Enum):
    MIN = "MIN"
    MAX = "MAX"
    min = "min"
    max = "max"


class NonAdditiveDimension(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    window_choice: Optional[WindowChoice] = None
    window_groupings: Optional[List[str]] = None


class NumberOrJinjaString(RootModel[Union[JinjaString, float]]):
    root: Union[JinjaString, float]


class RatioMetricTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    denominator: Optional[MetricInputSchema] = None
    filter: str = ""
    numerator: Optional[MetricInputSchema] = None


class SimpleMetricTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    measure: Optional[MetricInputMeasure] = None


class StringOrArrayOfStrings(RootModel[Union[str, ArrayOfStrings]]):
    root: Union[str, ArrayOfStrings]


class Severity(Enum):
    warn = "warn"
    error = "error"


class ValidityParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    is_end: Optional[bool] = None
    is_start: Optional[bool] = None


class Config(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    tags: Optional[StringOrArrayOfStrings] = None


class Analysis(BaseModel):
    name: str
    description: str = ""
    columns: Optional[List[Column]] = None
    config: Optional[Config] = None
    docs: Optional[DocsConfig] = None
    group: str = ""


class Exposure(BaseModel):
    name: str
    description: str = ""
    type: Type
    depends_on: List[str]
    label: str = ""
    maturity: Optional[Maturity] = None
    meta: Optional[Dict[str, Any]] = None
    owner: Owner
    tags: Optional[StringOrArrayOfStrings] = None
    url: str = ""


class Group(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    owner: Owner


class Macro(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    arguments: Optional[List[Argument]] = None
    docs: Optional[DocsConfig] = None


class SimpleMetricType(Enum):
    SIMPLE = "SIMPLE"
    simple = "simple"


class DerivedMetricType(Enum):
    DERIVED = "DERIVED"
    derived = "derived"


class CumulativeMetricType(Enum):
    CUMULATIVE = "CUMULATIVE"
    cumulative = "cumulative"


class ConversionMetricType(Enum):
    CONVERSION = "CONVERSION"
    conversion = "conversion"


class RatioMetricType(Enum):
    RATIO = "RATIO"
    ratio = "ratio"


class MetricBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        regex_engine="python-re",
    )
    name: str = Field(..., pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$")
    description: str = ""
    filter: str = ""
    group: str = ""
    label: str


class SimpleMetric(MetricBase):
    type: SimpleMetricType
    type_params: SimpleMetricTypeParams


class DerivedMetric(MetricBase):
    type: DerivedMetricType
    type_params: DerivedMetricTypeParams


class CumulativeMetric(MetricBase):
    type: CumulativeMetricType
    type_params: CumulativeMetricTypeParams


class ConversionMetric(MetricBase):
    type: ConversionMetricType
    type_params: ConversionMetricTypeParams


class RatioMetric(MetricBase):
    type: RatioMetricType
    type_params: RatioMetricTypeParams


Metric = Union[
    SimpleMetric, DerivedMetric, CumulativeMetric, ConversionMetric, RatioMetric
]


class QueryParams(BaseModel):
    dimensions: Optional[ArrayOfStrings] = None
    metrics: Optional[ArrayOfStrings] = None
    where: Optional[ArrayOfStrings] = None


class SavedQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str
    exports: Optional[List[Export]] = None
    label: str
    query_params: QueryParams


class UnitTestConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    meta: Optional[Dict[str, Any]] = None
    tags: Optional[StringOrArrayOfStrings] = None


class UnitTest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    config: Optional[UnitTestConfig] = Field(None, title="Unit Test Config")
    expect: Expect
    given: Optional[List[GivenItem]] = None
    model: str = Field(
        ...,
        description="The name of the model whose behaviour you are testing. Does not need to be wrapped in a ref.",
        examples=["my_model"],
    )
    overrides: Optional[Overrides] = None


class BooleanOrJinjaString(RootModel[Union[JinjaString, bool]]):
    root: Union[JinjaString, bool]


class Constraint(BaseModel):
    name: str = ""
    type: str
    columns: Optional[StringOrArrayOfStrings] = None
    expression: str = ""
    warn_unenforced: Optional[BooleanOrJinjaString] = None
    warn_unsupported: Optional[BooleanOrJinjaString] = None


class Constraints(RootModel[List[Constraint]]):
    root: List[Constraint]


class ConversionTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_measure: MetricInputMeasure
    calculation: Optional[Calculation] = Calculation.conversion_rate
    constant_properties: Optional[List[ConstantProperty]] = None
    conversion_measure: MetricInputMeasure
    entity: str = Field(..., description="The entity to calculate over")
    window: str = ""


class ConversionMetricTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    conversion_type_params: Optional[ConversionTypeParams] = None


class CumulativeMetricTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    grain_to_date: Optional[GrainToDate] = None
    measure: Optional[MetricInputMeasure] = None
    window: str = ""


class DerivedMetricTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expr: str = ""
    metrics: Optional[List[MetricInputSchema]] = None


class DimensionTypeParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    time_granularity: TimeGranularity
    validity_params: Optional[ValidityParams] = None


class FreshnessRules(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    count: NumberOrJinjaString
    period: Period


class Grants(RootModel[Dict[str, StringOrArrayOfStrings]]):
    root: Dict[str, StringOrArrayOfStrings] = Field(
        ...,
        description="grant config. each key is a database permission and the value is the grantee of that permission",
    )


class IncludeExclude(BaseModel):
    exclude: Optional[StringOrArrayOfStrings] = None
    include: Optional[StringOrArrayOfStrings] = None


class Measure(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        regex_engine="python-re",
    )
    name: str = Field(..., pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$")
    description: str = ""
    agg: Agg
    agg_params: Optional[AggregationTypeParams] = None
    agg_time_dimension: str = Field(
        "", pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$"
    )
    create_metric: Optional[bool] = None
    create_metric_display_name: str = ""
    expr: Optional[Union[str, int, bool]] = None
    label: str = ""
    non_additive_dimension: Optional[NonAdditiveDimension] = None


class Contract(BaseModel):
    enforced: BooleanOrJinjaString = True
    alias_types: BooleanOrJinjaString = False

class ModelConfigs(BaseModel):
    auto_refresh: BooleanOrJinjaString = True
    backup: BooleanOrJinjaString = False
    contract: Contract = {"enforced": True}
    file_format: str = ""
    grant_access_to: Optional[List[AuthorizedView]] = Field(
        None,
        description="Configuration, specific to BigQuery adapter, used to setup authorized views.",
        title="Authorized views",
    )
    grants: Optional[Grants] = None
    hours_to_expiration: float = Field(
        "",
        description="Configuration specific to BigQuery adapter used to set an expiration delay (in hours) to a table.",
    )
    kms_key_name: str = Field(
        "",
        description="Configuration of the KMS key name, specific to BigQuery adapter.",
        pattern="projects/[a-zA-Z0-9_-]*/locations/[a-zA-Z0-9_-]*/keyRings/.*/cryptoKeys/.*",
    )
    labels: Dict[str, str] = Field(
        {"key":"value"},
        description="Configuration specific to BigQuery adapter used to add labels and tags to tables/views created by dbt.",
        title="Label configs",
    )
    location: str = ""
    materialized: str = ""
    on_configuration_change: OnConfigurationChange = OnConfigurationChange.fail
    on_schema_change: Optional[OnSchemaChange] = OnSchemaChange.append_new_columns
    snowflake_warehouse: str = ""
    sql_header: str = ""
    target_lag: str = Field(
        "", pattern="^(?:downstream|\\d+\\s*(?:seconds|minutes|hours|days))$"
    )


class PersistDocsConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    columns: Optional[BooleanOrJinjaString] = Field(
        default_factory=lambda: BooleanOrJinjaString.model_validate(True)
    )
    relation: Optional[BooleanOrJinjaString] = Field(
        default_factory=lambda: BooleanOrJinjaString.model_validate(True)
    )


class TestConfigs(BaseModel):
    alias: str = Field(
        "", description="Only relevant when `store_failures` is true"
    )
    database: str = Field(
        "", description="Only relevant when `store_failures` is true"
    )
    enabled: Optional[BooleanOrJinjaString] = None
    error_if: str = ""
    fail_calc: str = ""
    limit: Optional[float] = None
    schema_: str = Field(
        "", alias="schema", description="Only relevant when `store_failures` is true"
    )
    severity: Optional[Union[JinjaString, Severity]] = None
    store_failures: Optional[BooleanOrJinjaString] = None
    tags: Optional[StringOrArrayOfStrings] = None
    warn_if: str = ""


class SnapshotConfig(BaseModel):
    alias: str = ""
    check_cols: Optional[StringOrArrayOfStrings] = None
    enabled: Optional[BooleanOrJinjaString] = None
    grants: Optional[Grants] = None
    persist_docs: Optional[PersistDocsConfig] = None
    post_hook: Optional[ArrayOfStrings] = Field(None, alias="post-hook")
    pre_hook: Optional[ArrayOfStrings] = Field(None, alias="pre-hook")
    quote_columns: Optional[BooleanOrJinjaString] = None
    strategy: str = ""
    tags: Optional[StringOrArrayOfStrings] = None
    target_database: str = ""
    target_schema: str = ""
    unique_key: Optional[StringOrArrayOfStrings] = None
    updated_at: str = ""


class Quoting(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    database: Optional[BooleanOrJinjaString] = None
    identifier: Optional[BooleanOrJinjaString] = None
    schema_: Optional[BooleanOrJinjaString] = Field(None, alias="schema")


class Relationships(BaseModel):
    name: str = ""
    config: Optional[TestConfigs] = None
    field: str = Field(
        ..., description="The foreign key column", title="Relationships: Field"
    )
    to: str = Field(
        ..., examples=["ref('parent_model')", "source('parent_schema', 'parent_table')"]
    )
    where: str = ""


class RelationshipsTest(BaseModel):
    relationships: Optional[Relationships] = None


class AcceptedValues(BaseModel):
    name: str = ""
    config: Optional[TestConfigs] = None
    quote: Optional[bool] = None
    values: List[str]
    where: str = ""


class AcceptedValuesTest(BaseModel):
    accepted_values: Optional[AcceptedValues] = None


class NotNull(BaseModel):
    name: str = ""
    config: Optional[TestConfigs] = None
    where: str = ""


class NotNullTest(BaseModel):
    not_null: Optional[NotNull] = None


class Unique(BaseModel):
    name: str = ""
    config: Optional[TestConfigs] = None
    where: str = ""


class UniqueTest(BaseModel):
    unique: Optional[Unique] = None


class DataTests(
    RootModel[
        Union[str, RelationshipsTest, AcceptedValuesTest, NotNullTest, UniqueTest]
    ]
):
    root: Union[str, RelationshipsTest, AcceptedValuesTest, NotNullTest, UniqueTest]


class DimensionBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        regex_engine="python-re",
    )
    name: str = Field(..., pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$")
    description: str = ""
    expr: Optional[Union[str, bool]] = None
    is_partition: Optional[bool] = None


class TimeDimensionType(Enum):
    TIME = "TIME"
    time = "time"


class CategoricalDimensionType(Enum):
    CATEGORICAL = "CATEGORICAL"
    categorical = "categorical"


class CategoricalDimension(DimensionBase):
    type: CategoricalDimensionType


class TimeDimension(DimensionBase):
    type: TimeDimensionType
    type_params: DimensionTypeParams


class Dimension(RootModel[Union[CategoricalDimension, TimeDimension]]):
    root: Union[CategoricalDimension, TimeDimension]


class FreshnessDefinition1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    error_after: Optional[FreshnessRules] = None
    filter: str = ""
    warn_after: Optional[FreshnessRules] = None


class FreshnessDefinition(RootModel[Union[FreshnessDefinition1, None]]):
    root: Union[FreshnessDefinition1, None]


class SeedConfig(BaseModel):
    column_types: Optional[Dict[str, Any]] = None
    copy_grants: Optional[BooleanOrJinjaString] = None
    data_tests: Optional[List[DataTests]] = None
    database: str = ""
    enabled: Optional[BooleanOrJinjaString] = None
    grants: Optional[Grants] = None
    quote_columns: Optional[BooleanOrJinjaString] = None
    schema_: str = Field(None, alias="schema")


class SemanticModel(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        regex_engine="python-re",
    )
    name: str = Field(..., pattern="(?!.*__).*^[a-z][a-z0-9_]*[a-z0-9]$")
    description: str = ""
    defaults: Optional[Defaults] = None
    dimensions: Optional[List[Dimension]] = None
    entities: Optional[List[Entity]] = None
    measures: Optional[List[Measure]] = None
    model: str
    primary_entity: str = ""


class ColumnProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    constraints: Optional[Constraints] = None
    data_tests: Optional[List[DataTests]] = None
    data_type: str = ""
    meta: Optional[Dict[str, Any]] = None
    policy_tags: Optional[List[str]] = Field(
        None,
        description="Configurations, specific to BigQuery adapter, used to set policy tags on specific columns, enabling column-level security. Only relevant when `persist_docs.columns` is true.",
        title="Policy tags",
    )
    quote: Optional[BooleanOrJinjaString] = None
    tags: Optional[StringOrArrayOfStrings] = None
    tests: Optional[List[DataTests]] = None


class Version(BaseModel):
    columns: Optional[List[Union[IncludeExclude, ColumnProperties]]] = None
    config: Optional[ModelConfigs] = None
    v: float


class Model(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    access: Optional[Access] = None
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[ModelConfigs] = None
    constraints: Optional[Constraints] = None
    data_tests: Optional[List[DataTests]] = None
    deprecation_date: str = ""
    docs: Optional[DocsConfig] = None
    group: str = ""
    latest_version: Optional[float] = None
    meta: Optional[Dict[str, Any]] = None
    tests: Optional[List[DataTests]] = None
    versions: Optional[List[Version]] = None


class Seed(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[SeedConfig] = Field(None, title="Seed Config")
    docs: Optional[DocsConfig] = None
    group: str = ""
    tests: Optional[List[DataTests]] = None


class Snapshot(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str
    description: str = ""
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[SnapshotConfig] = Field(None, title="Snapshot Config")
    data_tests: Optional[List[DataTests]] = None
    docs: Optional[DocsConfig] = None
    group: str = ""
    meta: Optional[Dict[str, Any]] = None
    tests: Optional[List[DataTests]] = None


class Table(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(
        ...,
        description="How you will identify the table in {{ source() }} calls. Unless `identifier` is also set, this will be the name of the table in the database.",
        title="Name",
    )
    description: str = ""
    columns: Optional[List[ColumnProperties]] = None
    external: Optional[Dict[str, Any]] = None
    freshness: Optional[FreshnessDefinition] = None
    identifier: str = Field(
        "",
        description="The table name as stored in the database. Only needed if you want to give the source a different name than what exists in the database (otherwise `name` is used by default)",
        title="Identifier",
    )
    loaded_at_field: str = Field(
        "",
        description="Which column to check during data freshness tests. Only needed if the table has a different loaded_at_field to the one defined on the source overall.",
    )
    loader: str = ""
    meta: Optional[Dict[str, Any]] = None
    quoting: Optional[Quoting] = None
    tags: Optional[StringOrArrayOfStrings] = None
    tests: Optional[List[DataTests]] = None


class Source(BaseModel):
    name: str = Field(
        ...,
        description="How you will identify the schema in {{ source() }} calls. Unless `schema` is also set, this will be the name of the schema in the database.",
    )
    description: str = ""
    config: Optional[Dict[str, Any]] = None
    data_tests: Optional[List[DataTests]] = None
    database: str = ""
    freshness: Optional[FreshnessDefinition] = None
    loaded_at_field: str = ""
    loader: str = ""
    meta: Optional[Dict[str, Any]] = None
    overrides: str = Field(
        "",
        description="The name of another package installed in your project. If that package has a source with the same name as this one, its properties will be applied on top of the base properties of the overridden source. https://docs.getdbt.com/reference/resource-properties/overrides",
        title="Package to Override",
    )
    quoting: Optional[Quoting] = None
    schema_: str = Field(
        "",
        alias="schema",
        description="The schema name as stored in the database. Only needed if you want to use a different `name` than what exists in the database (otherwise `name` is used by default)",
    )
    tables: Optional[List[Table]] = None
    tags: Optional[StringOrArrayOfStrings] = None
    tests: Optional[List[DataTests]] = None


class DbtYmlFiles(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Literal[2] = 2
    analyses: List[Analysis] = []
    exposures: List[Exposure] = []
    groups: List[Group] = []
    macros: List[Macro] = []
    metrics: List[Metric] = []
    models: List[Model] = []
    saved_queries: List[SavedQuery] = []
    seeds: List[Seed] = []
    semantic_models: List[SemanticModel] = []
    snapshots: List[Snapshot] = []
    sources: List[Source] = []
    unit_tests: List[UnitTest] = []
